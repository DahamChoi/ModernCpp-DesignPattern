# 프로토타입
*생성할 객체들의 타입이 프로토타입인 인스턴스로부터 결정되도록 하며, 인스턴스는 새 객체를 만들기 위해 자신을 복제(clone)하게 된다.*

## 객체생성
대부분 객체를 생성할 때 생성자를 이용한다. 하지만 이미 잘 설정된 객체가 있다면 같은 것을 복제하는 것이 가장 쉽다. 프로토타입의 패턴은 객체의 복제가 주요 기능이다. 당연하지만 객체를 복제하는 하나의 일관된 방법은 없다. 여기에는 여러 가지 옵션이 있고 그 중 몇 가지를 선택 할 수 있다.

## 평범한 중복 처리
복제의 목적이 값을 사용하는 것에 있고, 복제 대상 객체의 모든 항목이 값으로만 되어 있다면 복제하는데 문제 될 것이 전혀 없다. 그러나 내부 객체가 포인터로 된 경우 문제가 생긴다. 일반적인 대입으로 코드를 수행할 때 포인터가 복제되기 때문에 문제가 발생한다. (깊은 복사, 얕은 복사)

## 복제 생성자를 통한 중복 처리
중복을 피하는 가장 단순한 방법은 객체의 복제 생상자에서 내부 구성 요소들 모두를 적합하게 다루도록 정의하는 것이다. 여기에서 상식적인 대응은 복제 생성자를 포인터로 선언된 클래스에 정의하는 것이다. 그러면 상위 클래스의 생성자를 재활용하여 복제 생성자를 이용하게 할 수 있다.


이러한 방법은 아주 잘 동작한다. 이 방법의 유일한 문제는 온갖 복제 생성자를 하나하나 구현하는데 적지 않은 노력이 든다는 점이다. 도구를 이용하면 그러한 노력을 어느 정도 줄일 수는 있지만 여전히 손이 많이 가고 예상치 못한 까다로운 부분을 다루어야 할 수도 있다. 예를 들어 다음과 같은 코드가 작성되었다고 하자.

	Contact john = worker;
	
그리고 Contact안에 있는 포인터로 선언된 변수에 복제 생성자와 대입 연산자의 구현이 누락되었다고 하자. 이 코드는 컴파일 되는데 아무런 문제가 없다. 복제 생성자만 사용한다면 상황이 조금 더 낫다. 존재하지 않는 복제 생성자의 호출이 있으면 에러가 발생하여 문제를 인지할 수 있다. 하지만 대입 연산자는 모든 상황에서 디폴트 동작이 정해져 있으므로 대입 연사자를 정의하지 않았더라도 컴파일되고 실행되어 버린다. 


또 다른 문제도 있다. 이중 포인터 또는 unique_ptr을 사용한다면 어떻게 될까? 이런 경우는 도구를 이용해 올바른 코드를 생성하지 못한다.


또 다른 방법은 복제 생성자를 배제하고 아래와 같은 인터페이스를 별도로 두는 것이다.

	template <typename T> struct Cloneable
	{
		virtual T clone() const = 0;
	}

이 인터페이스를 구현하여 복제가 필요할 때 prototype.clone()을 호출한다. 이 방법은 가독성 측면에서 복제 생성자, 복제 대입 연산자보다 더 명료하다. 


어떤 방법이든 목적을 달성할 수 있다. 하지만 객체가 복잡하게 구성되어 있다면 꽤 손이 많이 갈 수 있다.


## 직렬화
직렬화를 활용해 객체 복제를 쉽게 만들 수 있다. (이하 내용 생략 -> 구현적인 측면을 다루고 있고 패턴적인 내용은 들어있지 않다)


## 프로토타입 팩터리
자주 복제해서 사용할 기본 객체들이 미리 정해져 있다면 그 객체들을 어디에 저장해 두어야 할까? 예를들어 회사 주소가 본점과 지점 두 곳이 있고 임직원 정보를 생성할 때마다 복제해서 쓴다고 하자. 본점 주소와 지점 주소를 어디에 두어야 할까? 직관적인 방법은 프로토타입을 저장할 별도의 클래스를 두고 프로토타입의 사용자가 원할 때, 목적에 맞는 복제본을 요구받는 시점에 만들어 제공하는 것이다. 이렇게 하면 전역변수보다 더 융통성 있는 일들이 가능해진다. 예를 들어 unique_ptr로 적절히 초기화하여 리턴해주는 편의 함수를 만들 수 있다.


왜 팩토리를 이용해야 하나? 사용자가 프로토타입을 복제한 다음 새로 설정해야 할 부분들을 누락할 수 있다. 즉, 올바른 데이터로 채워져 있어야 할 항목들이 null이거나 공백 문자인 채로 이용될 수 있다. 객체를 직접 복제한다면 이러한 누락을 피할 방법이 마땅치 않다. 하지만 모든 항목을 온전히 지정받는 생성자를 제외한 부분적인 생성자들을 모두 private를 선언하고 Factory만 friend로 선언되어 부분적인 생성자를 사용할 수 있게 했다고 하자. 그렇게 하면 미완성된 객체 복제본이 돌아다닐 가능성을 원천적으로 막을 수 있다.


[modern_cpp_designpattern/creational/prototype at main · DahamChoi/modern_cpp_designpattern (github.com)](https://github.com/DahamChoi/modern_cpp_designpattern/tree/main/creational/prototype)


## 요약
프로토타입 패턴은 객체의 깊은 복제를 수행하되 매번 전체 초기화를 하는 대신 미리 부분적으로 만들어진 객체를 복제하여 약간의 수정만으로 이용할 수 있게 한다. 이 과정에서 원복 객체에 대한 걱정은 하지 않아도 되게 해준다.


C++에서 프로토타입 패턴을 구현할 방법은 아래와 같이 두 가지 밖에 없다. 이 두방법 모두 수작업이 필요하다.
 - 객체의 깊은 복제를 올바르게 수행하는 코드를 작성한다. 복제 생성자나 복제 대입 연산자를 구현할 수도 있고 별도의 멤버 함수를 만들 수도 있다.
 - 직렬화/역직렬화 기능을 구현하여, 직렬화 직후 역직렬화를 하는 방법으로 복제를 한다. 이 방법은 부가적인 연산 비용이 발생한다. 이 비용이 심각할지 무시할만할지는 복제 작업을 얼마나 자주 하느냐에 달려 있다. 복제 생성자와 비교해 이 방법의 유일한 장점은 직렬화 기능이 덤으로 생긴다는 것 하나 뿐이다.

